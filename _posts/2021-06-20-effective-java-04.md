---
title: "Effective Java 클래스와 인터페이스"
search: true
categories: 
  - Java
last_modified_at: 2021-06-20T15:00:00
---

**이 글은 프로그래밍인사이트의 Effective Java 3/E를 읽고 요약 정리한 글입니다.**

**책 내용이 훨씬 정확하니 책을 사서 보세요**

**문제 시에 글을 내리겠습니다**

# 이펙티브 자바 - 클래스와 인터페이스

클래스와 인터페이스는 객체지향에서 중요한 개념인 추상화의 기본 단위입니다. 이번 장에서는 클래스와 인터페이스를 이용해서 좀 더 견고하고 유연하게 프로그램을 설계하는 방법에 대해 읽고 정리했습니다.

## Item 15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 내부의 데이터와 구현을 최대한 숨기고 오직 API를 통해서 다른 컴포넌트와 소통합니다. 어떻게(How) 동작하는 컴포넌트인지 최대한 감추고 무엇을(What) 하는 컴포넌트인지 공개하는 것이 좋습니다.

이 설계에 근간이 되는 원리가 정보 은닉(캡슐화)입니다.

정보은닉의 장점을 구체적으로 알아보면 다음과 같습니다.

* 시스템을 여러 컴포넌트로 나누고 병렬적으로 개발해서 시스템 개발 속도를 높일 수 있습니다.
* 시스템이 여러 컴포넌트로 분리돼있기 때문에 각 컴포넌트를 디버깅하거나 쉽게 교체할 수 있어서 시스템 관리 비용이 낮아집니다.
* 성능의 병목이 있는 컴포넌트를 프로파일링을 통해 찾아서 해당 컴포넌트만 최적화하면 되므로 성능 최적화가 쉬워집니다.
* 외부 의존성이 적은 컴포넌트라면 다른 환경에서도 재사용할 수 있습니다.
* 대규모 시스템을 제작하는 난이도를 낮춰줍니다. 전체 시스템 개발전에 각각의 컴포넌트의 동작을 검증할 수 있습니다.

자바에서도 이처럼 장점이 많은 정보 은닉을 위한 다양한 접근 제어 메커니즘을 제공합니다. 그 중 접근 제한자를 제대로 활용해서 정보 은닉을 구현할 수 있습니다.

기본 원칙은 간단합니다. **"모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다"**

클래스나 메소드를 public으로 공개하는 것을 최대한 신중히하고 가능하면 private으로 선언하고 패키지 내부에서만 package-private(default)로 선언해주는 것이 좋습니다.

외부에 클래스나 메소드를 한번 공개하면 그 다음부터는 하위 호환성을 계속 신경쓰면서 개발해야합니다. 따라서 내부 구현을 수정하기 쉽지 않아져서 유연성을 잃어버릴 수 있습니다.

클래스 인스턴스의 멤버 변수는 반드시 public이 아니도록 해야합니다. 클래스의 static 멤버 변수는 public static final인 상수나 불변 클래스를 제외하면 public으로 하면 안됩니다. 불변 클래스가 아니면 참조값만 유지한체로 내부 값을 변경할 수 있게됩니다.

접근 범위가 좁은 제한자부터 순서대로 살펴보겠습니다.

* private: 멤버를 선언한 톱레벨 클래스에서만 접근 가능
* package-private: 멤버를 선언한 톱레벨 클래스가 소속된 패키지 안의 모든 클래스가 접근 가능. 접근 제어자를 명시하지 않으면 package-private이 된다. 단, 인터페이스는 명시하지 않으면 기본이 public이다.
* protected: package-private + 이 멤버를 상속한 하위 클래스에서 접근 가능
* public: 모든 곳에서 접근 가능

jdk 9부터 제공되는 모듈에서는 protected, public의 의미가 약간 달라집니다. 외부에 공개된 모듈이 아니라면 모듈 내부에서만 접근이 가능합니다. 

정리하면 클래스의 멤버 변수 및 메소드는 가능하면 접근 범위를 좁게하고 꼭 필요한 API만 공개하도록 하는 것이 좋은 컴포넌트 설계를 만드는 좋은 방법입니다.

## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라

클래스의 멤버 변수는 반드시 외부에서 접근할 수 없도록 public이 아닌 접근 제어자를 사용하고 값을 제공하거나 변경기능을 제공하는 접근자 메소드를 사용해야 합니다.

클래스 필드를 외부에서 접근가능하도록 한번 공개하면 내부 데이터 표현 방법 변경시 해당 필드를 수정할 수 없게되고 클래스의 유연성이 매우 떨어지게 됩니다. 따라서 멤버 변수는 다음과 같이 접근자를 통해 제공해야합니다.

```
public class Point {
  private double x;
  private double y;

  public double getX() { reutrn x; }
  public double getY() { reutrn y; }

  public double setX(double x) { this.x = x; }
  public double setY(double y) { this.y = y; }
}
```

마지막으로 필드가 final이라 하더라도 public 접근제한자를 사용하는 것은 지양해야합니다. 내부 구현 변경시 final 필드도 변경해야할 가능성이 있습니다. 이 때 외부에서 해당 필드를 사용하고 있다면 변경이 불가능해집니다.

## Item 17. 변경 가능성을 최소화하라

인스턴스의 내부 값을 수정할 수 없도록 불변 클래스를 만들어서 변경 가능성을 최소화하면 객체의 설계와 구현, 사용이 매우 쉬워집니다. 또한 오류가 생길 여지도 적고 안전합니다.

다음 규칙을 따르면 불변 클래스를 만들 수 있습니다.

* 객체의 상태를 변경하는 메소드를 제공하지 않는다.
* 클래스를 확장할 수 없도록 한다.
* 모든 필드를 final로 선언한다.
* 모든 필드를 private으로 선언한다.
* 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 불변 클래스가 가변 객체를 참조하고 있다면 그 참조 값을 클라이언트에게 절대 반환하면 안됩니다.

불변 클래스는 다음과 같은 장점이 있습니다.

* 불변 객체는 매우 단순하며 Thread-Safe해서 따로 동기화할 필요가 없습니다. 
* 불변 객체는 자유롭게 공유 가능하고 불변 객체끼리는 내부 데이터를 공유할 수 있습니다.
* 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 불변식을 유지할 수 있고 신경쓰지 않아도 돼서 유지보수하기가 용이합니다. 그리고 불변 객체는 값이 변경되지 않으므로 Set 이나 Map 등의 키로 쓰기 좋습니다.

불변 클래스는 매번 연산시 객체를 생성해야한다는 단점이 있습니다. 이 때는 내부 구성요소는 최대한 불변 객체끼리 공유하고 클라이언트의 복잡한 연산을 미리 예상해서 가변 동반 클래스를 이용해 최적화 할 수 있습니다.

상속이 가능해지면 불변 클래스는 유지될 수 없을 수 도 있으므로 불변 클래스는 final로 선언하거나 생성자를 private, package-private로 지정하고 정적 팩토리 메소드를 만드는 것이 좋습니다.

## Item 18. 상속보다는 컴포지션을 사용하라

다른 클래스를 상속하는건 예상과 달리 캡슐화를 깨뜨릴수 있다. 상위 클래스의 구현에 따라 하위 클래스가 오동작할 수 있다. 이러한 이유때문에 문화를 충분히 잘 하거나 확장을 고려하고 설계를 잘해야한다.

특히 이 문제는 상위 클래스가 재정의 가능한 메소드를 자기 자신의 다른 메소드에서 호출할 때 많이 발생한다. 메소드가 재정의되면 상위 클래스의 구현이 하위 클래스의 구현에 의존하게되고 상위 클래스의 구현의 변경이 발생하면 하위 클래스에 영향을 미친다.

따라서 대부분의 경우에 상속보다는 컴포지션(구성)을 사용하는 것이 좋다.

컴포지션을 사용하려면 확장하고 싶은 클래스를 private 멤버로 포함시키고 포함한 클래스의 메소드 기능을 전달할 수 있는 전달 메소드를 만들면 된다. 컴포지션으로 작성한 클래스를 다른 인스턴스를 감쌌다고 해서 Wrapper 클래스라고도 한다.

상위 클래스가 this 참조를 전달해서 콜백을 호출하는 경우를 제오하면 대부분의 경우 상속보다는 컴포지션을 활용하는게 캡슐화를 지키기에 안전하다.

## Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

클라이언트가 상속을 해서 사용하도록 클래스를 구현하기로 결정했다면 문서화를 잘 하거나 재정의 될 메소드를 주의해서 작성해야한다.

재정의 가능한 메소드들을 내부적으로 어떻게 이용하고 어떤 순서로 호출되는지 문서로 남겨야 클라이언트가 클래스를 확장할 때 안전하게 구현할 수 있다. 자바독 문서에 Implementation Requirements로 시작하는 문장이 관련된 내용이다.

하지만 문서에 구현부를 노출하는 것은 좋은 방법이 아니라고 생각할 수 있다. 그렇다면 상속용 클래스를 좀 더 주의 깊게 작성하면 된다.

protected로 노출할 메소드가 재정의되어도 상속될 클래스의 내부 구현에 영향을 주지않도록 작성하면 된다. 어떤 메소드를 protected로 노출할 지 고민된다면 직접 하위 클래스를 몇개 만들어서 테스트 해보는 것이 좋다. 그리고 반드시 생성자에서는 재정의 가능한 메소드를 호출하면 안된다. 하위클래스의 멤버가 초기화가 되기전에 의도되지않은 동작이 발생할 수 있다.

이처럼 상속 클래스를 작성하는 것은 고려해야할 점도 많고 쉽지 않기 때문에 final로 선언하거나 private, pakcage-private 생성자를 만들어서 상속을 못하게 하고 클라이언트는 컴포지션을 통해 확장하도록 하는 것이 더 안전하다.

## Item 20. 추상 클래스보다는 인터페이스를 우선하라.

자바 8부터 인터페이스도 디폴트 메소드를 제공해서 추상 클래스와 인터페이스 모두 메소드를 구현 형태로 제공할 수 있다. 추상 클래스와 인터페이스의 가장 큰 차이는 추상 클래스는 단일 상속만 지원한다는 점이고 인터페이스는 여러개가 상속 가능하다는 점이다.

추상 클래스를 상속 받는 경우 하위 클래스는 다른 클래스를 상속받을 수 없다. 인터페이스는 기존 클래스에 추가로 구현해 넣기가 간단하지만 추상 클래스의 경우 기존 클래스가 다른 추상 클래스를 상속 받고 있으면 추가로 구현할 수 없다. 만일 확장하고 싶으면 기존 클래스의 추상 클래스를 상속한 형태의 추상클래스로 새로 만들어야하고 이는 복잡하고 의미가 불분명한 계층 구조를 만들 수 있다.

인터페이스를 사용하면 복잡한 계층 구조가 없이 믹스인 형태로 기존 클래스에 구현과 타입을 추가할 수 있다. 따라서 추상 클래스보다는 인터페이스로 타입을 작성하면 좀 더 유연한 설계를 만들 수 있다.

하지만 인터페이스에 메소드가 너무 많고 모든 메소드를 디폴트 메소드로 제공할 수 없는 경우에는 하위 클래스가 매번 구현하기 불편할 수 있다. 이 때는 인터페이스를 구현한 기본 골격 클래스인 동반 추상 클래스를 같이 제공해서 하위 클래스가 선택적으로 추상 클래스나 인터페이스를 사용할 수 있도록 제공하는 것이 좋다. 

## Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8에서 인터페이스에 디폴트 메소드가 생기면서 인터페이스에 메소드를 추가하는데 부담이 줄었다. 하지만 디폴트 메소드도 모든 상황에서 불변식을 해치지 않도록 작성하기가 쉽지 않다.

인터페이스가 한번 릴리즈되고 클라이언트들에게 쓰이면 새로운 메소드를 추가하면 부작용이 많이 생길 수 있다. 디폴트 메소드는 이 부작용을 어느정도 우회할 수 있지만 일부 상황에서는 오작동을 일으킬 수 있다. 따라서 처음 인터페이스를 설계할 때 신중히 작성하고 디폴트 메소드를 추가해야한다면 반드시 많은 테스트를 거치도록 하는 것이 좋다.

## Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 타입을 정의하는 용도로 설계됐다. 인스턴스가 어떤 인터페이스를 구현한다는 것은 인스턴스 사용자에게 인스턴스가 그러한 타입을 가졌고 어떤 메소드를 가졌는지 나타낸다.

인터페이스에 상수 값을 넣는 것은 바람직하지 못하다. 클라이언트가 한번 의존하는 순간 바꿀수 없기 떄문이다. 상수는 유틸 클래스, 일반 클래스, 열거형 등을 사용하자.

## Item 23. 태그 달린 클래보다는 클래스 계층구조를 활용하라

태그는 인스턴스가 어떤 유형인지 멤버 변수로 나타내는 값이다. 태그를 사용하는 클래스는 단점이 많다. 계속 추가되는 switch, if문 태그 유형마다 달라지는 로직, 태그를 위한 필드 등 여러가지 구현이 한 클래스에 혼합된다.

태그 달린 클래스는 장황하고, 오류 내기 쉽고, 비효율적이다. 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내 낸 아류이다.

따라서 태그 달린 클래스 대신 잘 설계된 계층 구조를 이용하면 된다. root가 될 추상 클래스를 정의하고 종류에 따라 달라지는 동작을 추상메소드로 선언한다. 추상 클래스를 상속하는 하위 클래스는 종류에 따라 달라지는 동작을 정의하면 된다.

클래스 계층 구조는 태그 달린 클래스의 장점들을 모두 없앨 수 있다. 쓸모없는 분기문과 필드가 사라지고 필요한 동작과 필드만 가질 수 있다. 계층 관계 덕분에 유연성과 컴파일 타입 검사 능력도 높일 수 있다.

## Item 24. 멤버 클래스는 되도록 static으로 만들라

중첩 클래스는 클래스 안에 정의된 클래스로 자신을 감싼 바깥 클래스에서만 쓰여여한다. 종류는 정적 멤버 클래스, 멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네 가지다.

정적 멤버 클래스는 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 일반 클래스 와 같다. 정적 멤버 클래스는 다른 정적 멤버처럼 바깥 클래스의 접근 제어자의 영향을 받는다.

(비정적) 멤버 클래스는 static이 붙어있지 않지만 차이는 매우 크다. 바깥 클래스의 인스턴스와 암묵적으로 연결되고 바깥 클래스 인스턴스의 this에 접근이 가능하다. 클래스명.this 형태의 정규화 된 this로 접근이 가능하다. 바깥 클래스 인스턴스 생성시 자동으로 인스턴스가 생성되고 연결된다.

멤버 클래스에서 바깥 인스턴스에 접근할 일이 없으면 무조건 static 클래스로 만들어야한다. 비정적 멤버 클래스는 숨은 바깥 인스턴스 참조를 갖게 되고 **메모리 누수**가 생길 가능성이 있다.

멤버 클래스가 public이나 protected로 구현된다면 더욱 주의해야한다. 한번 외부에 공개하면 수정하기가 불가능하다.

익명 클래스는 선언과 동시에 인스턴스가 만들어진다. 익명 클래스는 instanceof 검사나 클래스 이름이 필요한 작업은 수행할 수 없다. 인터페이스를 하나만 구현하거나 클래스를 하나만 상속할 수 있다. 또한 비정적 문맥에서만 바깥 인스턴스를 참조할 수 있다.

지역 클래스는 지역 변수를 선언할 수 있는 곳에서 선언할 수 있고 유효범위도 지역변수와 같다. 거의 쓰임이 적다.

## Item 25. 톱레벨 클래스는 파일당 하나만 담아라

톱레벨 클래스를 한 파일에 여러개 선언하는 건 아무런 득도 안되고 컴파일 시 복잡해지기만 한다. 반드시 한 파일에 하나의 클래스만 선언하도록 하자.