---
title: "Effective Java 메소드"
search: true
categories: 
  - Java
last_modified_at: 2021-07-20T21:00:00
---

**이 글은 프로그래밍인사이트의 Effective Java 3/E를 읽고 요약 정리한 글입니다.**

**책 내용이 훨씬 정확하니 책을 사서 보세요**

**문제 시에 글을 내리겠습니다**

# 이펙티브 자바 - 메소드

메서드를 설계할 때 주의할 점들을 정리했습니다.

## Item 49. 매개변수가 유효한지 검사하라

메소드 몸체가 실행되기 전에 매개변수가 유효한지 검사하면 예외를 깔끔하게 던질수 있다. 매개변수를 제대로 검사하지 않으면 문제가 생길 수 있다.

1. 메소드 실행중에 애매한 에러가 발생하면 원인을 파악하기 힘들다. ex) NullPointerException
2. 더 나쁜 상황은 에러 발생 없이 이상한 값을 반환하는 것이다.
3. 한층 더 나쁜 상황은 메소드는 정상동작 하지만 부작용으로 객체의 상태를 이상하게 바꿔서 미래에 알 수 없는 버그를 만드는 것이다.

이처럼 매개변수는 최대한 빨리 검사하는 것이 좋다. 또한 매개변수 값이 잘못됐을 때 던지는 예외를 자바독의 @throws 태그로 문서화하면 클라이언트가 좀 더 안전하게 메소드를 사용할 수 있다.

공개되지 않은 메소드(not public)이라면 유효성 검증 대신 assert 문을 사용해도 된다. 반드시 assert 문을 통과할 수 있다는 확신이 있을때만 사용하자.

마지막으로 메소드가 직접 사용하지 않고 저장했다가 나중에 사용하는 매개변수라면 더욱 주의해서 유효성 검사를 진행해야한다. 예상치 못한 버그를 만들 가능성이 높다.

지금까지 설명한 내용을 보고 "매개변수의 제약을 두는게 좋다"고 생각하면 안된다. 제약이 적고 범용성이 좋은 메소드가 사용하기 좋다. 하지만 제약이 필요한 경우에는 반드시 유효한지 검사하자.

## Item 50. 적시에 방어적 복사본을 만들라

클래스는 접근 제어자를 이용해서 상태를 안전하게 관리할 수 있다. 하지만 필드에 참조를 저장하는 경우에는 해당 필드의 상태를 외부에서 바꿀수 있다. 따라서 사용자가 악의적이든 실수든 클래스 내부의 불변식을 깨뜨릴 수 있다.

예를들어 다음과 같은 클래스가 있다고 하자
```
public final class Period {
  private final Date start;
  private final Date end;

  public Period(Date start, Date end) {
    if (start.compareTo(end) > 0) {
      throw new IllegalArgumentException("invalid date range");
    }
    this.start = start;
    this.end = end;
  }

  public Date start() {
    return start;
  }

  public Date end() {
    return end;
  }
}
```

이 클래스는 Date의 참조를 저장하고 있기 때문에 클래스가 생성된 이후 외부에서 조작이 가능하다. 따라서 다음과 같이 생성자에서 방어적 복사본을 만들어서 저장하는 것이 좋다.

```
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());

  if (this.start.compareTo(this.end) > 0) {
    throw new IllegalArgumentException("invalid date range");
  }
}

public Date start() {
  return new Date(start.getTime());
}

public Date end() {
  return new Date(end.getTime());
}
```

복사본을 먼저 만들어서 저장한 이유는 멀티스레드 프로그래밍 등에서 해당 변수가 유효성 검사 이후에 변조될 수 있기 떄문이다. 또한 getter 메소드도 반환시 복사본을 반환해야 외부에서 변경하는 것을 막을 수 있다.

불변 클래스인 Instant나 LocalDatTime, ZonedDateTime을 사용하는 것도 방법이다. 방어적 복사본은 성능에 영향을 줄 수 있기 때문에 상황에 따라서 적절히 관리해줘야 한다. 문서화를 통해 변경하지 말라고 안내하는 것도 방법이다.

## Item 51. 메소드 시그니처를 신중히 설계하라

메소드를 잘 설계하기 위한 요령을 정리한 챕터이다.

1. 메소드 이름은 신중히 짓자. 일관성 있고 의미가 분명한 이름을 짓자.
2. 편의 메소드를 너무 많이 만들지 말자. 메소드가 많을 수록 클래스를 사용하기 어렵고 유지보수하기 힘들어진다.
3. 매개변수 목록은 짧게 유지하자. 4개 이하가 좋다. 4개가 넘어가면 기억하기 힘들다. 메소드를 여러개의 메소드로 쪼개거나 매개변수를 객체로 묶자
4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다. 특정 클래스를 사용하면 메소드의 범용성이 떨어진다.
5. boolean 보다는 원소 2개짜리 열거 타입이 낫다. 확장에 안전하고 의미가 분명하다.

## Item 52. 다중정의는 신중히 사용하라

같은 개수의 유사한 파라미터를 다중정의하게 되면 사용시 혼동을 일으킬 수 있다. 안전하게 가려면 매개변수 수가 같은 다중정의는 피하자. 다중정의를 사용하지 않고 메소드 이름을 바꿔주는 방법도 있다.

매개변수 수가 같은 다중 정의를 만들어야 하는 상황이 생긴다면 혼동이 되는 타입을 섞어서 사용하지 말자. 매개변수 중 하나 이상이 "근본적으로 다르게 해야한다". 타입이 혼동되지 않도록 주의하자

재정의한 메소드는 동적으로 선택되지만 다중정의는 정적으로 선택된다. 따라서 다중정의는 컴파일 시점의 타입의 영향을 받기 때문에 주의해서 사용해야한다. 다형성의 장점을 사용할 수 없다.

마지막으로 함수형 인터페이스는 서로 타입이 다르더라도 같은 위치의 인수로 받아서는 안된다. 메소드 참조를 사용하거나 람다식을 사용할 때 어떤 메소드가 사용되는지 불분명하기 때문이다.

가능하면 같은 수의 매개변수 다중정의는 하지말자.

## Item 53. 가변인수는 신중히 사용하라

가변인수는 인수 개수가 정해져 있지 않을 떄 유용하다. 하지만 성능이 민감한 상황에서는 좋지 않다. 매번 호출할 때 마다 배열이 생성되기 때문이다. 대부분 호출이 매개변수가 적다면 다음과 같은 기법을 사용하면 좋다.

```
public void foo() {}
public void foo(int a1) {}
public void foo(int a1, int a2) {}
public void foo(int a1, int a2, int a3) {}
public void foo(int a1, int a2, int a3, int ...rest) {}
```

매개변수가 3개일 때까지는 가변인수를 사용하지 않기때문에 배열이 생성되지 않는다.

## Item 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.

배열이나 컬렉션을 반환하는 메소드에서 null을 반환하게 되면 사용자가 예외처리를 하기 매우 번거롭고 실수할 가능성이 생긴다. 이때 빈 컬렉션이나 배열을 반환하면 안전하고 편리하게 사용할 수 있다.

## Item 55. 옵셔널 반환은 신중히 하라

옵셔널은 원소를 최대 1개 가질수 있는 불변 컬렉션이다. null을 반환하는 메소드나 예외를 던지는 메소드보다 Optional을 반환하는 메소드가 유연하고 오류가능성이 적다.

Optional을 반환할 때는 반드시 Optional 객체를 반환해야한다. null을 반환하게 되면 Optional 도입 취지를 무시함과 동시에 버그를 만들 수 있다. 

또한 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안된다. 빈 컨테이너를 반환하는 것이 더 좋다.

박싱된 기본 타입을 담는 옵셔널은 사용하지말고 자바에서 제공해주는 OptionalInt, OptionalLong, OptionalDouble을 사용하자.

마지막으로 Optional은 메소드 반환시에만 사용하고 다른 용도로는 사용하지 말자.

## Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라

API를 올바로 문서화하려면 공개된 모든 클래스, 인터페이스, 메소드, 필드 선언에 문서화 주석을 달아야한다. 클라이언트가 사용하기에도 유용하고 유지보수하기에도 좋다.

메소드용 문서화 주석에는 해당 메소드와 클라이언트 사이의 규약을 명료하게 기술해야 한다. how가 아닌 what을 기술해야한다.

클래스를 상속용으로 설계할 떄는 @implSpec 주석을 사용해서 자기 사용 패턴을 문서화해야한다.

마지막으로 문서화에서 자주 누락되는 요소가 있다. 스레드 안전 수준과 직렬화 가능성을 반드시 문서화 하자.

올바른 문서화를 검증하는 방법은 생성된 문서를 전부 읽어보는 법 밖에 없다. 꼼꼼히 읽어보자.